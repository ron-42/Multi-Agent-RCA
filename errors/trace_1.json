[
    {
        "event_attributes": {
            "exception.escaped": true,
            "exception.language": "python",
            "exception.message": "type object 'User' has no attribute 'emails'",
            "exception.stack_details": "[\n  {\n    \"exception.file\": \"/usr/srv/app/services/user.py\",\n    \"exception.line\": 18,\n    \"exception.function_name\": \"create_user_account\",\n    \"exception.function_body\": \"async def create_user_account(data, session, background_tasks):\\n    \\n    user_exist = session.query(User).filter(User.emails == data.email).first()\\n    if user_exist:\\n        raise HTTPException(status_code=400, detail=\\\"Email is already exists.\\\")\\n    \\n    if not is_password_strong_enough(data.password):\\n        raise HTTPException(status_code=400, detail=\\\"Please provide a strong password.\\\")\\n    \\n    \\n    user = User()\\n    user.name = data.name\\n\",\n    \"exception.start_line\": 16,\n    \"exception.end_line\": 27,\n    \"exception.is_file_external\": \"false\"\n  },\n  {\n    \"exception.file\": \"/usr/srv/app/routes/user.py\",\n    \"exception.line\": 35,\n    \"exception.function_name\": \"register_user\",\n    \"exception.function_body\": \"@user_router.post(\\\"\\\", status_code=status.HTTP_201_CREATED, response_model=UserResponse)\\nasync def register_user(data: RegisterUserRequest, background_tasks: BackgroundTasks, session: Session = Depends(get_session)):\\n    return await user.create_user_account(data, session, background_tasks)\\n\",\n    \"exception.start_line\": 33,\n    \"exception.end_line\": 35,\n    \"exception.is_file_external\": \"false\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/fastapi/routing.py\",\n    \"exception.line\": 190,\n    \"exception.function_name\": \"run_endpoint_function\",\n    \"exception.function_body\": \"async def run_endpoint_function(\\n    *, dependant: Dependant, values: Dict[str, Any], is_coroutine: bool\\n) -\u003e Any:\\n    # Only called by get_request_handler. Has been split into its own function to\\n    # facilitate profiling endpoints, since inner functions are harder to profile.\\n    assert dependant.call is not None, \\\"dependant.call must be a function\\\"\\n\\n    if is_coroutine:\\n        return await dependant.call(**values)\\n    else:\\n        return await run_in_threadpool(dependant.call, **values)\\n\",\n    \"exception.start_line\": 182,\n    \"exception.end_line\": 192,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/fastapi/routing.py\",\n    \"exception.line\": 273,\n    \"exception.function_name\": \"app\",\n    \"exception.function_body\": \"        solved_result = await solve_dependencies(\\n            request=request,\\n            dependant=dependant,\\n            body=body,\\n            dependency_overrides_provider=dependency_overrides_provider,\\n        )\\n        values, errors, background_tasks, sub_response, _ = solved_result\\n        if errors:\\n            raise RequestValidationError(_normalize_errors(errors), body=body)\\n        else:\\n            raw_response = await run_endpoint_function(\\n                dependant=dependant, values=values, is_coroutine=is_coroutine\\n            )\\n\\n            if isinstance(raw_response, Response):\\n                if raw_response.background is None:\\n                    raw_response.background = background_tasks\\n                return raw_response\\n            response_args: Dict[str, Any] = {\\\"background\\\": background_tasks}\\n            # If status_code was set, use it, otherwise use the default from the\\n\",\n    \"exception.start_line\": 263,\n    \"exception.end_line\": 282,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/starlette/routing.py\",\n    \"exception.line\": 66,\n    \"exception.function_name\": \"app\",\n    \"exception.function_body\": \"    async def app(scope: Scope, receive: Receive, send: Send) -\u003e None:\\n        request = Request(scope, receive=receive, send=send)\\n        if is_coroutine:\\n            response = await func(request)\\n        else:\\n            response = await run_in_threadpool(func, request)\\n        await response(scope, receive, send)\\n\",\n    \"exception.start_line\": 63,\n    \"exception.end_line\": 69,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/starlette/routing.py\",\n    \"exception.line\": 276,\n    \"exception.function_name\": \"handle\",\n    \"exception.function_body\": \"    async def handle(self, scope: Scope, receive: Receive, send: Send) -\u003e None:\\n        if self.methods and scope[\\\"method\\\"] not in self.methods:\\n            headers = {\\\"Allow\\\": \\\", \\\".join(self.methods)}\\n            if \\\"app\\\" in scope:\\n                raise HTTPException(status_code=405, headers=headers)\\n            else:\\n                response = PlainTextResponse(\\n                    \\\"Method Not Allowed\\\", status_code=405, headers=headers\\n                )\\n            await response(scope, receive, send)\\n        else:\\n            await self.app(scope, receive, send)\\n\",\n    \"exception.start_line\": 265,\n    \"exception.end_line\": 276,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/starlette/routing.py\",\n    \"exception.line\": 718,\n    \"exception.function_name\": \"__call__\",\n    \"exception.function_body\": \"            return\\n\\n        partial = None\\n\\n        for route in self.routes:\\n            # Determine if any route matches the incoming scope,\\n            # and hand over to the matching route if found.\\n            match, child_scope = route.matches(scope)\\n            if match == Match.FULL:\\n                scope.update(child_scope)\\n                await route.handle(scope, receive, send)\\n                return\\n            elif match == Match.PARTIAL and partial is None:\\n                partial = route\\n                partial_scope = child_scope\\n\\n        if partial is not None:\\n            # \\u00a0Handle partial matches. These are cases where an endpoint is\\n            # able to handle the request, but is not a preferred option.\\n            # We use this in particular to deal with \\\"405 Method Not Allowed\\\".\\n\",\n    \"exception.start_line\": 708,\n    \"exception.end_line\": 727,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py\",\n    \"exception.line\": 17,\n    \"exception.function_name\": \"__call__\",\n    \"exception.function_body\": \"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -\u003e None:\\n        dependency_exception: Optional[Exception] = None\\n        async with AsyncExitStack() as stack:\\n            scope[self.context_name] = stack\\n            try:\\n                await self.app(scope, receive, send)\\n            except Exception as e:\\n                dependency_exception = e\\n                raise e\\n        if dependency_exception:\\n            # This exception was possibly handled by the dependency but it should\\n            # still bubble up so that the ServerErrorMiddleware can return a 500\\n            # or the ExceptionMiddleware can catch and handle any other exceptions\\n            raise dependency_exception\\n\",\n    \"exception.start_line\": 12,\n    \"exception.end_line\": 25,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py\",\n    \"exception.line\": 20,\n    \"exception.function_name\": \"__call__\",\n    \"exception.function_body\": \"    async def __call__(self, scope: Scope, receive: Receive, send: Send) -\u003e None:\\n        dependency_exception: Optional[Exception] = None\\n        async with AsyncExitStack() as stack:\\n            scope[self.context_name] = stack\\n            try:\\n                await self.app(scope, receive, send)\\n            except Exception as e:\\n                dependency_exception = e\\n                raise e\\n        if dependency_exception:\\n            # This exception was possibly handled by the dependency but it should\\n            # still bubble up so that the ServerErrorMiddleware can return a 500\\n            # or the ExceptionMiddleware can catch and handle any other exceptions\\n            raise dependency_exception\\n\",\n    \"exception.start_line\": 12,\n    \"exception.end_line\": 25,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py\",\n    \"exception.line\": 68,\n    \"exception.function_name\": \"__call__\",\n    \"exception.function_body\": \"        response_started = False\\n\\n        async def sender(message: Message) -\u003e None:\\n            nonlocal response_started\\n\\n            if message[\\\"type\\\"] == \\\"http.response.start\\\":\\n                response_started = True\\n            await send(message)\\n\\n        try:\\n            await self.app(scope, receive, sender)\\n        except Exception as exc:\\n            handler = None\\n\\n            if isinstance(exc, HTTPException):\\n                handler = self._status_handlers.get(exc.status_code)\\n\\n            if handler is None:\\n                handler = self._lookup_exception_handler(exc)\\n\\n\",\n    \"exception.start_line\": 58,\n    \"exception.end_line\": 77,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py\",\n    \"exception.line\": 79,\n    \"exception.function_name\": \"__call__\",\n    \"exception.function_body\": \"        except Exception as exc:\\n            handler = None\\n\\n            if isinstance(exc, HTTPException):\\n                handler = self._status_handlers.get(exc.status_code)\\n\\n            if handler is None:\\n                handler = self._lookup_exception_handler(exc)\\n\\n            if handler is None:\\n                raise exc\\n\\n            if response_started:\\n                msg = \\\"Caught handled exception, but response already started.\\\"\\n                raise RuntimeError(msg) from exc\\n\\n            if scope[\\\"type\\\"] == \\\"http\\\":\\n                request = Request(scope, receive=receive)\\n                if is_async_callable(handler):\\n                    response = await handler(request, exc)\\n\",\n    \"exception.start_line\": 69,\n    \"exception.end_line\": 88,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/opentelemetry/instrumentation/asgi/__init__.py\",\n    \"exception.line\": 735,\n    \"exception.function_name\": \"__call__\",\n    \"exception.function_body\": \"                )\\n\\n                otel_send = self._get_otel_send(\\n                    current_span,\\n                    span_name,\\n                    scope,\\n                    send,\\n                    attributes,\\n                )\\n\\n                await self.app(scope, otel_receive, otel_send)\\n        finally:\\n            if scope[\\\"type\\\"] == \\\"http\\\":\\n                target = _collect_target_attribute(scope)\\n                if target:\\n                    path, query = _parse_url_query(target)\\n                    _set_http_target(\\n                        attributes,\\n                        target,\\n                        path,\\n\",\n    \"exception.start_line\": 725,\n    \"exception.end_line\": 744,\n    \"exception.is_file_external\": \"true\"\n  },\n  {\n    \"exception.file\": \"/usr/local/lib/python3.11/site-packages/opentelemetry/trace/__init__.py\",\n    \"exception.line\": 590,\n    \"exception.function_name\": \"use_span\",\n    \"exception.function_body\": \"            context as error event on the span.\\n        set_status_on_exception: Only relevant if the returned span is used\\n            in a with/context manager. Defines whether the span status will\\n            be automatically set to ERROR when an uncaught exception is\\n            raised in the span with block. The span status won't be set by\\n            this mechanism if it was previously set manually.\\n    \\\"\\\"\\\"\\n    try:\\n        token = context_api.attach(context_api.set_value(_SPAN_KEY, span))\\n        try:\\n            yield span\\n        finally:\\n            context_api.detach(token)\\n\\n    except Exception as exc:  # pylint: disable=broad-exception-caught\\n        if isinstance(span, Span) and span.is_recording():\\n            # Record the exception as an event\\n            if record_exception:\\n                span.record_exception(exc)\\n\\n\",\n    \"exception.start_line\": 580,\n    \"exception.end_line\": 599,\n    \"exception.is_file_external\": \"true\"\n  }\n]",
            "exception.stacktrace": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.11/site-packages/opentelemetry/trace/__init__.py\", line 590, in use_span\n    yield span\n  File \"/usr/local/lib/python3.11/site-packages/opentelemetry/instrumentation/asgi/__init__.py\", line 735, in __call__\n    await self.app(scope, otel_receive, otel_send)\n  File \"/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py\", line 79, in __call__\n    raise exc\n  File \"/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py\", line 68, in __call__\n    await self.app(scope, receive, sender)\n  File \"/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py\", line 20, in __call__\n    raise e\n  File \"/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py\", line 17, in __call__\n    await self.app(scope, receive, send)\n  File \"/usr/local/lib/python3.11/site-packages/starlette/routing.py\", line 718, in __call__\n    await route.handle(scope, receive, send)\n  File \"/usr/local/lib/python3.11/site-packages/starlette/routing.py\", line 276, in handle\n    await self.app(scope, receive, send)\n  File \"/usr/local/lib/python3.11/site-packages/starlette/routing.py\", line 66, in app\n    response = await func(request)\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/fastapi/routing.py\", line 273, in app\n    raw_response = await run_endpoint_function(\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/fastapi/routing.py\", line 190, in run_endpoint_function\n    return await dependant.call(**values)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/srv/app/routes/user.py\", line 35, in register_user\n    return await user.create_user_account(data, session, background_tasks)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/srv/app/services/user.py\", line 18, in create_user_account\n    user_exist = session.query(User).filter(User.emails == data.email).first()\n                                            ^^^^^^^^^^^\nAttributeError: type object 'User' has no attribute 'emails'\n",
            "exception.type": "AttributeError"
        },
        "event_name": "exception",
        "event_timestamp_nanos": 1765542794030469728
    }
]